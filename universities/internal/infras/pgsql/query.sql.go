// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package postgresql

import (
	"context"
	"database/sql"
	"time"
)

const addPanorama = `-- name: AddPanorama :one
insert into university_panoramas (university_id, address, name, firstlocation, secondlocation, type)
values ($1, $2, $3, $4, $5, $6)
returning university_id, address, name, firstlocation, secondlocation, type
`

type AddPanoramaParams struct {
	UniversityID   string        `json:"university_id"`
	Address        string        `json:"address"`
	Name           string        `json:"name"`
	Firstlocation  string        `json:"firstlocation"`
	Secondlocation string        `json:"secondlocation"`
	Type           PanoramaTypes `json:"type"`
}

func (q *Queries) AddPanorama(ctx context.Context, arg AddPanoramaParams) (UniversityPanorama, error) {
	row := q.db.QueryRowContext(ctx, addPanorama,
		arg.UniversityID,
		arg.Address,
		arg.Name,
		arg.Firstlocation,
		arg.Secondlocation,
		arg.Type,
	)
	var i UniversityPanorama
	err := row.Scan(
		&i.UniversityID,
		&i.Address,
		&i.Name,
		&i.Firstlocation,
		&i.Secondlocation,
		&i.Type,
	)
	return i, err
}

const createReview = `-- name: CreateReview :one
insert into university_reviews(university_id,
                               author_status,
                               sentiment, date,
                               text, review_id, parent_review_id)
values ($1, $2, $3, $4, $5, $6, $7)
returning university_id, author_status, sentiment, date, text, review_id, parent_review_id
`

type CreateReviewParams struct {
	UniversityID   string         `json:"university_id"`
	AuthorStatus   Statuses       `json:"author_status"`
	Sentiment      Sentiments     `json:"sentiment"`
	Date           time.Time      `json:"date"`
	Text           string         `json:"text"`
	ReviewID       string         `json:"review_id"`
	ParentReviewID sql.NullString `json:"parent_review_id"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (UniversityReview, error) {
	row := q.db.QueryRowContext(ctx, createReview,
		arg.UniversityID,
		arg.AuthorStatus,
		arg.Sentiment,
		arg.Date,
		arg.Text,
		arg.ReviewID,
		arg.ParentReviewID,
	)
	var i UniversityReview
	err := row.Scan(
		&i.UniversityID,
		&i.AuthorStatus,
		&i.Sentiment,
		&i.Date,
		&i.Text,
		&i.ReviewID,
		&i.ParentReviewID,
	)
	return i, err
}

const getOpenDays = `-- name: GetOpenDays :many

select u.name, od.description, od.address, od.link, od.date
from university_open_days od
         join universities u on u.id = od.university_id
where u.id = $1
`

type GetOpenDaysRow struct {
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Address     string    `json:"address"`
	Link        string    `json:"link"`
	Date        time.Time `json:"date"`
}

func (q *Queries) GetOpenDays(ctx context.Context, id string) ([]GetOpenDaysRow, error) {
	rows, err := q.db.QueryContext(ctx, getOpenDays, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOpenDaysRow
	for rows.Next() {
		var i GetOpenDaysRow
		if err := rows.Scan(
			&i.Name,
			&i.Description,
			&i.Address,
			&i.Link,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPanoramas = `-- name: GetPanoramas :many
select university_id, address, name, firstlocation, secondlocation, type
from university_panoramas p
where university_id = $1
  and type = $2
order by p.name
`

type GetPanoramasParams struct {
	UniversityID string        `json:"university_id"`
	Type         PanoramaTypes `json:"type"`
}

func (q *Queries) GetPanoramas(ctx context.Context, arg GetPanoramasParams) ([]UniversityPanorama, error) {
	rows, err := q.db.QueryContext(ctx, getPanoramas, arg.UniversityID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UniversityPanorama
	for rows.Next() {
		var i UniversityPanorama
		if err := rows.Scan(
			&i.UniversityID,
			&i.Address,
			&i.Name,
			&i.Firstlocation,
			&i.Secondlocation,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviews = `-- name: GetReviews :many
select r.university_id, r.author_status, r.sentiment, r.date, r.text, r.review_id, r.parent_review_id,
       (select count(*)
        from university_reviews
        where parent_review_id = r.review_id) as reply_count
from university_reviews r
where r.university_id = $3
group by r.review_id, r.date
order by r.date
offset $1 limit $2
`

type GetReviewsParams struct {
	Offset       int32  `json:"offset"`
	Limit        int32  `json:"limit"`
	UniversityID string `json:"university_id"`
}

type GetReviewsRow struct {
	UniversityID   string         `json:"university_id"`
	AuthorStatus   Statuses       `json:"author_status"`
	Sentiment      Sentiments     `json:"sentiment"`
	Date           time.Time      `json:"date"`
	Text           string         `json:"text"`
	ReviewID       string         `json:"review_id"`
	ParentReviewID sql.NullString `json:"parent_review_id"`
	ReplyCount     int64          `json:"reply_count"`
}

func (q *Queries) GetReviews(ctx context.Context, arg GetReviewsParams) ([]GetReviewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviews, arg.Offset, arg.Limit, arg.UniversityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsRow
	for rows.Next() {
		var i GetReviewsRow
		if err := rows.Scan(
			&i.UniversityID,
			&i.AuthorStatus,
			&i.Sentiment,
			&i.Date,
			&i.Text,
			&i.ReviewID,
			&i.ParentReviewID,
			&i.ReplyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByParent = `-- name: GetReviewsByParent :many
select university_id, author_status, sentiment, date, text, review_id, parent_review_id
from university_reviews r
where r.parent_review_id = $1
order by r.date
`

func (q *Queries) GetReviewsByParent(ctx context.Context, parentReviewID sql.NullString) ([]UniversityReview, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsByParent, parentReviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UniversityReview
	for rows.Next() {
		var i UniversityReview
		if err := rows.Scan(
			&i.UniversityID,
			&i.AuthorStatus,
			&i.Sentiment,
			&i.Date,
			&i.Text,
			&i.ReviewID,
			&i.ParentReviewID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopOfUniversities = `-- name: GetTopOfUniversities :many
select id, name, long_name, logo, rating, region, budget_places, type, study_fields
from universities u
order by u.rating desc
limit $1
`

func (q *Queries) GetTopOfUniversities(ctx context.Context, limit int32) ([]University, error) {
	rows, err := q.db.QueryContext(ctx, getTopOfUniversities, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []University
	for rows.Next() {
		var i University
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LongName,
			&i.Logo,
			&i.Rating,
			&i.Region,
			&i.BudgetPlaces,
			&i.Type,
			&i.StudyFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniversities = `-- name: GetUniversities :many
select id, name, long_name, logo, rating, region, budget_places, type, study_fields
from universities u
order by u.name
offset $1 limit $2
`

type GetUniversitiesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetUniversities(ctx context.Context, arg GetUniversitiesParams) ([]University, error) {
	rows, err := q.db.QueryContext(ctx, getUniversities, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []University
	for rows.Next() {
		var i University
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LongName,
			&i.Logo,
			&i.Rating,
			&i.Region,
			&i.BudgetPlaces,
			&i.Type,
			&i.StudyFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniversity = `-- name: GetUniversity :one
select id, name, long_name, logo, rating, region, budget_places, type, study_fields
from universities
where id = $1
limit 1
`

func (q *Queries) GetUniversity(ctx context.Context, id string) (University, error) {
	row := q.db.QueryRowContext(ctx, getUniversity, id)
	var i University
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LongName,
		&i.Logo,
		&i.Rating,
		&i.Region,
		&i.BudgetPlaces,
		&i.Type,
		&i.StudyFields,
	)
	return i, err
}

const searchUniversities = `-- name: SearchUniversities :many
select id, name, long_name, logo, rating, region, budget_places, type, study_fields
from universities
where name ilike $1
   or long_name ilike $2
order by name
`

type SearchUniversitiesParams struct {
	Name     string `json:"name"`
	LongName string `json:"long_name"`
}

func (q *Queries) SearchUniversities(ctx context.Context, arg SearchUniversitiesParams) ([]University, error) {
	rows, err := q.db.QueryContext(ctx, searchUniversities, arg.Name, arg.LongName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []University
	for rows.Next() {
		var i University
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LongName,
			&i.Logo,
			&i.Rating,
			&i.Region,
			&i.BudgetPlaces,
			&i.Type,
			&i.StudyFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
